apply plugin: 'java'
// apply plugin: 'application'

//设置 Java 兼容版本
sourceCompatibility = 1.8
targetCompatibility = 1.8

ext.classifier      = 'jdk8' // ':'
ext.quasarVer       = '0.7.10'

[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

configurations {
    quasar
}

configurations.all {
    resolutionStrategy {
        failOnVersionConflict()
    }
}

repositories {
    mavenLocal() // cache (USER_HOME/.m2 folder)
    maven{ //2.其次查找aliyun maven库
        url 'http://maven.aliyun.com/nexus/content/groups/public/'
    }
    mavenCentral()

}

// 强制指定一个版本
// 给有冲突的 jar 包强制指定一个版本
configurations.all{
    resolutionStrategy{
        force 'org.slf4j:slf4j-api:1.7.25'
        force 'io.netty:netty-all:4.1.42.Final'
    }
}

dependencies {
	// https://mvnrepository.com/artifact/co.paralleluniverse/quasar-core
	compile group: 'co.paralleluniverse', name: 'quasar-core', version: "${quasarVer}"
    // quasar "co.paralleluniverse:quasar-core:${quasarVer}:${classifier}@jar"
    
    // mvn -Dmaven.test.skip=true clean \
    //		compile \
    //		package \
    //		install \
    //		org.apache.maven.plugins:maven-dependency-plugin:3.1.1:properties \
    //		org.fortasoft:gradle-maven-plugin:1.0.8:invoke \
    //		package \
    //		install
    //
    // gradle这里依赖同版本的ejoker库，与mvn构建命令中的两次install对应,
    // 前一个install构建一个没有instrumentation的包，里面会提供相关依赖关系，
    // gradle会继承这些关系。
    // !!! 如果不要继承这些关系的话，那么需要把所有maven的pom.xml声明的依赖包全部写到这里。依赖升级时也要逐一对应
    // !!! 相比之下，还是继承一个没有instrumentation的包来的方便。
    // 如果不需要使用quasar，则前4个声明周期即可构建功能完备的ejoker
    // gradle-maven-plugin:invoke 就是调用此gradle任务的起点。
    // 后一个instal则是安装已经instrumentation的包的。
    compile "pro.jiefzz:ejoker-common:2.0.0-snapshot-4"
    
}

// 改变项目默认结构，使其与与maven目录结构一致
sourceSets {
    // 设置源代码所在目录
    main {
        java {
            srcDirs = ["src/main/java"]
        }
        resources {
            srcDirs = ["src/main/resources"] // 资源目录
        }
        output.classesDir = file('target/classes')
        output.resourcesDir = file('target/classes')
    }
}

// 改变编译目录
buildDir = 'target'

task scanSuspendables() {
	doFirst {
		File iSrcFile = new File("${project.rootDir}/src/main/resources/metaInf/suspendables")
		File iDestFile = new File("$sourceSets.main.output.resourcesDir/META-INF/suspendables")
		(new File(iDestFile.getParent())).mkdirs()
		iDestFile << iSrcFile.text
		
		File sSrcFile = new File("${project.rootDir}/src/main/resources/metaInf/suspendable-supers")
		File sDestFile = new File("$sourceSets.main.output.resourcesDir/META-INF/suspendable-supers")
		(new File(sDestFile.getParent())).mkdirs()
		sDestFile << sSrcFile.text
	}
	doLast {
		ant.taskdef(name:'scanSuspendables', classname:'co.paralleluniverse.fibers.instrument.SuspendablesScanner',
		    classpath: "target/classes:${configurations.runtime.asPath}")
		ant.scanSuspendables(
		    auto: true,
		    suspendablesFile: "$sourceSets.main.output.resourcesDir/META-INF/suspendables",
		    supersFile: "$sourceSets.main.output.resourcesDir/META-INF/suspendable-supers",
		    append: true) {
		    fileset(dir: sourceSets.main.output.classesDir)
		}
	}
}

compileJava.dependsOn processResources
compileJava {
    doLast {
        ant.taskdef(name:'instrumentation', classname:'co.paralleluniverse.fibers.instrument.InstrumentationTask', classpath: configurations.compile.asPath)
        ant.instrumentation(verbose:'true', check:'true', debug:'true') {
            fileset(dir: sourceSets.main.output.classesDir)
        }
    }
}
